#pragma kernel CSMain

struct Icon
{
	float2 center;
	float size;
	float4 tileUv;
};

struct Capsules
{
	float2 a;
	float2 b;
};

Texture2D<float4> _IconSource;
StructuredBuffer<Icon> _Icons;
StructuredBuffer<Capsules> _Capsules;
uint _IconCount;
uint _CapsuleCount;
float2 _InvTexSize;
float _LineThickness;
SamplerState linear_clamp_sampler;

RWTexture2D<float4> _Result;

float2 InverseLerp(float2 a, float2 b, float2 t)
{
	return (t - a) / (b - a);
}

//From Inigo Quilez : https://iquilezles.org/articles/distfunctions2d/
float SegmentDist(float2 p, float2 a, float2 b)
{
	float2 pa = p - a, ba = b - a;
	float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
	return length(pa - ba * h);
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	float2 uv = id.xy * _InvTexSize;
	uv = 1.0 - uv;
	float4 color = 0;
    
    //Icons
	uint i = 0;
	for (i = 0; i < _IconCount; i++)
	{
		Icon icon = _Icons[i];
		float2 localUV = InverseLerp(icon.center - icon.size * 0.5, icon.center + icon.size * 0.5, uv);

		if (any(localUV < 0 || localUV > 1))
			continue;
            
		float4 iconColor = _IconSource.SampleLevel(linear_clamp_sampler, lerp(icon.tileUv.xy, icon.tileUv.zw, localUV), 0);
		color.xw += iconColor.x;
		
		//Discs
		if (length(uv - icon.center) < _LineThickness)
			color.zw = 1;
	}
	
	//Capsules
	for (i = 0; i < _CapsuleCount; i++)
	{
		Capsules capsule = _Capsules[i];

		if (SegmentDist(uv, capsule.a, capsule.b) < _LineThickness)
		{
			color.yw = 1;
		}
	}
	
	_Result[id.xy] = color;
}
